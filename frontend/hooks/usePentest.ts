
import React, { useState, useEffect } from 'react';
import { Node } from '../types';
import { NetWatchApi } from '../services/api';

export const usePentest = (setNodes: React.Dispatch<React.SetStateAction<Node[]>>) => {
  const [logs, setLogs] = useState<string[]>([]);

  useEffect(() => {
    // Listen for alert events from tools
    const handleAlert = (alert: any) => {
      addOutput(`[!] ALERT: ${alert.title} (${alert.severity})`);
      if (alert.severity === 'critical') {
         addLog(`System Compromise Detected on ${alert.device_ip}`);
      }
    };
    NetWatchApi.on('alert.created', handleAlert);
    return () => NetWatchApi.off('alert.created', handleAlert);
  }, []);

  const addLog = (cmd: string) => {
    setLogs(prev => {
      const newLogs = [...prev, `root@kali:~# ${cmd}`];
      return newLogs.length > 8 ? newLogs.slice(newLogs.length - 8) : newLogs;
    });
  };

  const addOutput = (output: string) => {
     setLogs(prev => {
        const newLogs = [...prev, output];
        return newLogs.length > 8 ? newLogs.slice(newLogs.length - 8) : newLogs;
     });
  };

  const executeCommand = async (tool: string, selectedIds: string[]) => {
    if (selectedIds.length === 0) {
      addLog(`${tool} --help`);
      addOutput(`Error: No target specified. Select a node first.`);
      return;
    }

    // Try API first
    try {
      const targets = selectedIds.join(',');
      addLog(`${tool} -T ${targets}`);

      // Call backend with proper payload: executeTool(toolName, task, params)
      const result = await NetWatchApi.executeTool(tool, 'scan', { target_ids: selectedIds });
      addOutput(`[+] Tool ${tool} execution completed`);
      if (result.result) {
        addOutput(`[+] Result: ${JSON.stringify(result.result).slice(0, 100)}...`);
      }

    } catch (e) {
      // Fallback Simulation
      console.warn("Tool API failed, simulating response");
      simulateExecution(tool, selectedIds);
    }
  };

  const simulateExecution = (tool: string, selectedIds: string[]) => {
    selectedIds.forEach(id => {
      if (tool === 'nmap') {
        setTimeout(() => {
          const commonPorts = [21, 22, 80, 443, 3306, 8080, 5432, 27017];
          const foundPorts = commonPorts.sort(() => 0.5 - Math.random()).slice(0, Math.floor(Math.random() * 4) + 1);
          
          setNodes(prev => prev.map(n => n.id === id ? { 
            ...n, 
            ports: foundPorts 
          } : n));
          addOutput(`[+] Nmap: ${foundPorts.length} open ports discovered on ${id}`);
        }, 1500);
      }
      
      if (tool === 'hydra') {
        setNodes(prev => prev.map(n => n.id === id ? { ...n, status: 'warning' } : n));
        setTimeout(() => {
             addOutput(`[!] Hydra: Brute force successful on ${id}. Creds found.`);
        }, 2000);
      }

      if (tool === 'metasploit') {
        setTimeout(() => {
          setNodes(prev => prev.map(n => n.id === id ? { 
            ...n, 
            status: 'compromised',
            vulnerabilities: ['CVE-2024-3094'], // Legacy fallback
            detailedVulnerabilities: [
              {
                cve: 'CVE-2024-3094',
                cvss: 10.0,
                severity: 'critical',
                description: 'Malicious code in xz-utils liblzma results in remote code execution via SSH.',
                references: ['https://nvd.nist.gov/vuln/detail/CVE-2024-3094']
              },
              {
                cve: 'CVE-2021-44228',
                cvss: 10.0,
                severity: 'critical',
                description: 'Apache Log4j2 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints.',
                references: ['https://nvd.nist.gov/vuln/detail/CVE-2021-44228']
              }
            ]
          } : n));
          addOutput(`[*] Meterpreter session 1 opened against ${id}`);
          addOutput(`[+] TARGET COMPROMISED`);
        }, 3000);
      }
    });
  };

  return { logs, executeCommand };
};
