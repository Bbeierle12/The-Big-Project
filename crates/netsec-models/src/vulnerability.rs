//! Vulnerability model types.

use chrono::Utc;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::alert::Severity;

/// A discovered vulnerability (database row).
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "sqlx", derive(sqlx::FromRow))]
pub struct Vulnerability {
    pub id: String,
    pub cve_id: Option<String>,
    pub cvss_score: Option<f64>,
    pub severity: String,
    pub title: String,
    pub description: String,
    pub device_id: Option<String>,
    pub port: Option<i64>,
    pub source_tool: String,
    pub solution: Option<String>,
    pub created_at: String,
    pub updated_at: String,
}

impl Vulnerability {
    pub fn new(title: String, source_tool: String, severity: Severity) -> Self {
        let now = Utc::now().to_rfc3339();
        Self {
            id: Uuid::new_v4().to_string(),
            cve_id: None,
            cvss_score: None,
            severity: severity.as_str().to_string(),
            title,
            description: String::new(),
            device_id: None,
            port: None,
            source_tool,
            solution: None,
            created_at: now.clone(),
            updated_at: now,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vuln_serde_roundtrip() {
        let v = Vulnerability::new("SQL Injection".into(), "openvas".into(), Severity::High);
        let json = serde_json::to_string(&v).unwrap();
        let back: Vulnerability = serde_json::from_str(&json).unwrap();
        assert_eq!(back.title, "SQL Injection");
        assert_eq!(back.severity, "high");
    }

    // A7: Constructor defaults
    #[test]
    fn test_vulnerability_constructor_defaults() {
        let v = Vulnerability::new("XSS".into(), "nikto".into(), Severity::Medium);
        assert_eq!(v.title, "XSS");
        assert_eq!(v.source_tool, "nikto");
        assert_eq!(v.severity, "medium");
        assert_eq!(v.description, "");
        assert!(v.cve_id.is_none());
        assert!(v.cvss_score.is_none());
        assert!(v.device_id.is_none());
        assert!(v.port.is_none());
        assert!(v.solution.is_none());
        uuid::Uuid::parse_str(&v.id).expect("id should be valid UUID");
        assert!(!v.created_at.is_empty());
        assert!(!v.updated_at.is_empty());
    }
}
