//! Vulnerability model types.

use chrono::Utc;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::alert::Severity;

/// A discovered vulnerability (database row).
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "sqlx", derive(sqlx::FromRow))]
pub struct Vulnerability {
    pub id: String,
    pub cve_id: Option<String>,
    pub cvss_score: Option<f64>,
    pub severity: String,
    pub title: String,
    pub description: String,
    pub device_id: Option<String>,
    pub port: Option<i64>,
    pub source_tool: String,
    pub solution: Option<String>,
    pub created_at: String,
    pub updated_at: String,
}

impl Vulnerability {
    pub fn new(title: String, source_tool: String, severity: Severity) -> Self {
        let now = Utc::now().to_rfc3339();
        Self {
            id: Uuid::new_v4().to_string(),
            cve_id: None,
            cvss_score: None,
            severity: severity.as_str().to_string(),
            title,
            description: String::new(),
            device_id: None,
            port: None,
            source_tool,
            solution: None,
            created_at: now.clone(),
            updated_at: now,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vuln_serde_roundtrip() {
        let v = Vulnerability::new("SQL Injection".into(), "openvas".into(), Severity::High);
        let json = serde_json::to_string(&v).unwrap();
        let back: Vulnerability = serde_json::from_str(&json).unwrap();
        assert_eq!(back.title, "SQL Injection");
        assert_eq!(back.severity, "high");
    }
}
